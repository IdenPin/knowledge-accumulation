### 缓存
缓存分为强缓存和协商缓存。强缓存不过服务器，协商缓存需要经过服务器，协商缓存返回的状态码是304。这两类缓存机制可以同时存在，强缓存的优先级高于协商缓存。当执行强缓存时，如若缓存命中，则直接使用缓存数据库中的数据，不再进行缓存协商。

#### 强缓存
##### Expires（HTTP1.0）
值为服务端返回的数据到期时间。当再次请求时的时间小于返回的此时间，则直接使用缓存数据。但由于服务端时间和客户端时间可能有误差，从而导致缓存命中的误差（使用的是绝对时间，难以保证服务端时间和客户端时间一致）。另一方面，Expires是HTTP1.0的产物，现在大多数使用Cache-Control替代

##### Cache-Control（HTTP1.1）
 - private -> 客户端可以缓存
 - public -> 客户端和代理服务器都可以缓存
 - max-age=t -> 缓存内容将在t秒后失效
 - no-cache -> 需要使用协商缓存来验证缓存数据
 - no-store -> 所有内容都不会缓存
*注意： no-cache 是可以缓存，但是每次用应该去向服务器验证缓存是否可用。no-store 才是不缓存内容，当首部字段 Cache-Control 有指定 max-age 指令时，比起首部字段 Expires，会优先处理 max-age 指令。强缓存的表现形式是，firefox 为一个灰色的200状态码。chrome 浏览器状态码表现为 200（from dist cache）或 200 ok(from memory cache)*


##### Pragma(HTTP1.0)
当值为 no-cache 时强制验证缓存，Pragma 禁用缓存，如果又给 Expires 定义一个还未到期的时间，那么 pragma 字段优先级会更高。服务端响应添加 Pragma: no-cache，浏览器表现行为和刷新（F5）类似

### 协商缓存
协商缓存是需要进行对比判断是否可以使用缓存，浏览器第一次请求数据时，服务器会将缓存标示于数据一起响应给客户端，客户端将他们备份至缓存中。再次请求时，客户端会将缓存中的标识发送给服务器，服务器根据此标识去判断。若未失效，返回304，浏览器拿到此状态就可以直接使用缓存数据了

#### Last-Modified 
服务器在响应请求时，会告诉浏览器资源的最后修改时间

#### if-modified-since 
浏览器再次请求服务器的时候，请求头会包含此字段，后面跟着在缓存中获得的最后修改时间。服务端收到此请求头发现有if-Modified-Since，则与被请求资源的最后修改时间进行对比，如果一致则返回304和响应报文头，浏览器只需要从缓存中获取信息即可。
  - 如果真的被修改：那么开始传输响应一个整体，服务器返回：200 OK
  - 如果没有被修改：那么只需传输响应header，服务器返回：304 Not Modified

  这两个的区别是一个是修改了才下载一个是没修改才下载。如果在服务器上，一个资源被修改了，但其实际内容根本没发生改变，会因为Last-Modified时间匹配不上而返回了整个实体给客户端（即使客户端缓存里有个一模一样的资源）。为了解决这个问题，HTTP1.1推出了Etag。

#### ETag
服务器响应请求时，通过此字段告诉浏览器当前资源在服务器生成的唯一标识（生成规则由服务器决定）

#### if-Match 
条件请求，携带上一次请求中资源的ETag，服务器根据这个字段判断文件是否有新的修改

#### if-None-Match 
再次请求时，浏览器的请求报文头会包含此字段，后面的值为在混存中获取的标识，服务器接收到次报文后发现if-none-match 则于被请求资源的唯一标识进行对比


### 缓存场景
大部分场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略
 - 对于某些不需要缓存的资源，可以使用 cache-control:no-store，表示该资源不需要缓存
 - 对于频繁变动的资源，可以使用 cache-control:no-catch 并配合 ETag 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新
 - 对于代码文件来说，通常使用 cache-control:max-age=31536000并配合策略缓存使用，然后对文件进行指纹处理，一单文件变动就回立刻下载新的文件













